# 结构化绑定声明
(在C++17中引入)

结构化绑定声明是一个**声明语句**，意味着声明了一些**标识符**并对标识符做了初始化。
将指定的一些名字绑定到初始化器的子对象或者元素上。
只能使用auto关键字来把指定的名字初始化为初始化器中对应位置的元素上。

## 声明形态
 
- cv-auto &/&&(可选) [标识符列表] = 表达式;

- cv-auto &/&&(可选) [标识符列表] { 表达式 };

- cv-auto &/&&(可选) [标识符列表] ( 表达式 );

此处的一些符号解释：

- cv-auto: 可能由const/volatile修饰的auto关键字。

- &/&& 左值引用或者右值引用。

- 标识符列表：逗号分隔的标识符，大括号中的内容为初始化器。

 

## 原生数组的结构化绑定声明
若初始化表达式为数组类型，则标识符列表中的名字绑定到数组元素
- 标识符数量必须等于数组元素数量
- 标识符类型与数组元素类型一致
``` c++
int main() {
  int priArr [] {42, 21, 7};//原生数组类型。
  // 此处定义的ai/bi/ci 的基本类型都是int，只是cv标识或引用标识不同。
  auto [a1, a2, a3] = priArr; // a1 是 priArr[0] 的拷贝，a2, a3类推
  const auto [b1, b2, b3] (priArr); // b1 是 priArr[0] 的只读拷贝，b2, b3类推
  auto &[c1, c2, c3] {priArr}; // c1 是 priArr[0] 的引用，c2, c3类推
  c3 = 14;                     // priArr[2]的值变为14
  return 0;
}
```
## 用于std::array的结构化绑定声明
取代原生数组，包含自身的长度属性。数据处理效率基本相同。
若初始化表达式为数组类型，则标识符列表中的名字绑定到数组元素
- 标识符数量必须等于std::array数组中的元素数量
- 标识符类型与std::array中的数组元素类型一致

```cpp
int main() {
  std::array<char,3> stdArr = {'a','b','c'};// 模板的自动推导。
  auto [d1, d2, d3] {stdArr}; 
  return 0;
}
```

## 用于对象数据成员的结构化绑定声明
 

若初始化表达式为类/结构体类型，则标识符列表中的名字绑定到类/结构体的非静态数据成员上

- 数据成员必须为公有成员（对于结构体来讲所有数据成员都是公有的）

- 标识符数量必须等于数据成员的数量

- 标识符类型与数据成员类型一致

- auto后跟&，则标识符是数据成员的引用

- auto前可放置const，表明标识符是只读的

```cpp
class C {  // 可以改用 struct C，然后去掉下面的public属性说明
public:
  int i { 420 }; // 就地初始化
  char ca[ 3 ] { 'O', 'K', '!' };
};

int main() {
  C c;
  auto [a1, a2] {c}; // a1是int类型，a2是char[]类型
  std::cout << "c.i:" << a1 << " c.ca:" << b2 << std::endl;
}
```

```cpp
int main() {
  C c; // c.i: 420;  c.ca: 'O','K','!'
  auto [a1, a2] {c}; // a1是c.i的**拷贝**，a2是char[]类型
  auto& [b1, b2] {c}; // b1是int&类型，是c.i的引用，b2是char(&)[3]类型(数组的引用)，是c.ca的引用
  a1 = 100;
  std::cout << "c.i:" << c.i << std::endl; // 输出420，改a1不影响c.i
  b1 = 200;
  std::cout << "c.i:" << c.i << std::endl; // 输出200，通过b1修改了c.i

}
```
 

 